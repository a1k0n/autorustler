#include <Eigen/Dense>
#include "ekf.h"

// This file is auto-generated by ekf/codegen.py. DO NOT EDIT.

using Eigen::VectorXf;
using Eigen::MatrixXf;

#define Min(x, y) fminf(x, y)
#define Max(x, y) fmaxf(x, y)

static inline float Heaviside(float x) {
  return x < 0 ? 0 : 1;
}

static inline float DiracDelta(float x) {
  return x == 0;
}

EKF::EKF() : x_(15), P_(15, 15) {
  Reset();
}


void EKF::Reset() {
  x_ << 0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        3.68040895462036,
        1.38629436492920,
        0.0,
        2.47643613815308,
        1.00000000000000,
        0.0,
        3.00000000000000,
        -60.0000000000000,
        117.000000000000,
        0.0;
  P_.setIdentity();
  P_.diagonal() << 1.00000011116208e-6,
    0.0100000007078052,
    4.00000000000000,
    1.00000000000000,
    1.00000000000000,
    0.0625000000000000,
    0.0625000000000000,
    0.0625000000000000,
    1.00000000000000,
    0.0100000007078052,
    0.0100000007078052,
    0.0100000007078052,
    2500.00000000000,
    100.000000000000,
    1.00000000000000;
}

void EKF::Predict(float Delta_t, float u_M, float u_delta) {
  float v = x_[0];
  float delta = x_[1];
  float y_e = x_[2];
  float psi_e = x_[3];
  float kappa = x_[4];
  float ml_1 = x_[5];
  float ml_2 = x_[6];
  float ml_3 = x_[7];
  float ml_4 = x_[8];
  float srv_a = x_[9];
  float srv_b = x_[10];
  float srv_r = x_[11];

  float tmp0 = exp(ml_4);
  float tmp1 = exp(ml_3);
  float tmp2 = tmp1*v;
  float tmp3 = fabsf(u_M);
  float tmp4 = tmp3*exp(ml_2);
  float tmp5 = tmp4*v;
  float tmp6 = tmp3*exp(ml_1)*Heaviside(u_M);
  float tmp7 = Heaviside(-Delta_t*(-tmp0 - tmp2 - tmp5 + tmp6) - v);
  float tmp8 = -Delta_t*(tmp0 + tmp2 + tmp5 - tmp6);
  float tmp9 = Heaviside(tmp8 + v);
  float tmp10 = Delta_t*tmp9;
  float tmp11 = tmp10*(tmp1 + tmp4);
  float tmp12 = -delta + srv_a*u_delta + srv_b;
  float tmp13 = Delta_t*srv_r;
  float tmp14 = fabsf(tmp12);
  float tmp15 = Min(tmp13, tmp14);
  float tmp16 = (((tmp12) > 0) - ((tmp12) < 0));
  float tmp17 = 2*tmp15*DiracDelta(tmp12) + pow(tmp16, 2)*Heaviside(tmp13 - tmp14);
  float tmp18 = sin(psi_e);
  float tmp19 = Delta_t*((1.0L/2.0L)*tmp11 + (1.0L/2.0L)*tmp7 - 1);
  float tmp20 = cos(psi_e);
  float tmp21 = Max(tmp8, -v);
  float tmp22 = Delta_t*((1.0L/2.0L)*tmp21 + v);
  float tmp23 = tmp20*tmp22;
  float tmp24 = pow(Delta_t, 2);
  float tmp25 = (1.0L/2.0L)*tmp18*tmp24*tmp9;
  float tmp26 = kappa*y_e;
  float tmp27 = tmp26 - 1;
  float tmp28 = 1.0/tmp27;
  float tmp29 = kappa*tmp28;
  float tmp30 = delta - tmp20*tmp29;
  float tmp31 = tmp18*tmp22;
  float tmp32 = (1.0L/2.0L)*tmp24*tmp30*tmp9;

  MatrixXf F(15, 15);
  F.setIdentity();
  F(0, 0) += -tmp11 - tmp7;
  F(0, 5) += tmp10*tmp6;
  F(0, 6) += -tmp10*tmp5;
  F(0, 7) += -tmp10*tmp2;
  F(0, 8) += -tmp0*tmp10;
  F(1, 1) += -tmp17;
  F(1, 9) += tmp17*u_delta;
  F(1, 10) += tmp17;
  F(1, 11) += Delta_t*tmp16*Heaviside(-tmp13 + tmp14);
  F(2, 0) += -tmp18*tmp19;
  F(2, 3) += tmp23;
  F(2, 5) += tmp25*tmp6;
  F(2, 6) += -tmp25*tmp5;
  F(2, 7) += -tmp2*tmp25;
  F(2, 8) += -tmp0*tmp25;
  F(3, 0) += -tmp19*tmp30;
  F(3, 1) += tmp22;
  F(3, 2) += pow(kappa, 2)*tmp23/pow(tmp27, 2);
  F(3, 3) += tmp29*tmp31;
  F(3, 4) += tmp23*tmp28*(tmp26*tmp28 - 1);
  F(3, 5) += tmp32*tmp6;
  F(3, 6) += -tmp32*tmp5;
  F(3, 7) += -tmp2*tmp32;
  F(3, 8) += -tmp0*tmp32;

  VectorXf Q(15);
  Q << 16, 4, 1, 1, 100, 0.0100000000000000, 0.000100000000000000, 0.000100000000000000, 0.0100000000000000, 0.000100000000000000, 0.000100000000000000, 0.000100000000000000, 1.00000000000000e-6, 1.00000000000000e-10, 1.00000000000000e-10;
  x_[0] += tmp21;
  x_[1] += tmp15*tmp16;
  x_[2] += tmp31;
  x_[3] += tmp22*tmp30;

  P_ = F * P_ * F.transpose();
  P_.diagonal() += Delta_t * Q;
}

bool EKF::UpdateCenterline(float a, float b, float c, Eigen::MatrixXf Rk) {
  float y_e = x_[2];
  float psi_e = x_[3];
  float kappa = x_[4];
  float tmp0 = pow(b, 2) + 1;
  float tmp1 = 2*pow(tmp0, -1.5);


  VectorXf yk(3);
  yk << -(c + y_e),
        -psi_e + atan(b),
        a*tmp1 - kappa;

  MatrixXf Hk(3, 15);
  Hk << 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0;
  MatrixXf Mk(3, 3);
  Mk << 0, 0, -1,
        0, 1.0/tmp0, 0,
        tmp1, -6.0*a*b*pow(tmp0, -2.5), 0;
  Rk = Mk * Rk * Mk.transpose();

  MatrixXf S = Hk * P_ * Hk.transpose() + Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

  x_.noalias() += K * yk;
  P_ = (MatrixXf::Identity(15, 15) - K*Hk) * P_;
  return true;
}

bool EKF::UpdateIMU(float g_z) {
  float v = x_[0];
  float delta = x_[1];
  float o_g = x_[14];


  VectorXf yk(1);
  yk << delta*v + g_z - o_g;

  MatrixXf Hk(1, 15);
  Hk << -delta, -v, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1;

  VectorXf Rk(1);
  Rk << 0.0100000000000000;

  MatrixXf S = Hk * P_ * Hk.transpose();
  S.diagonal() += Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

  x_.noalias() += K * yk;
  P_ = (MatrixXf::Identity(15, 15) - K*Hk) * P_;
  return true;
}

bool EKF::UpdateEncoders(float dsdt, float fb_delta) {
  float v = x_[0];
  float delta = x_[1];
  float srvfb_a = x_[12];
  float srvfb_b = x_[13];


  VectorXf yk(2);
  yk << dsdt - 63.0316606304536*v,
        -delta*srvfb_a + fb_delta - srvfb_b;

  MatrixXf Hk(2, 15);
  Hk << 63.0316606304536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, srvfb_a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, delta, 1, 0;

  VectorXf Rk(2);
  Rk << 1, 1;

  MatrixXf S = Hk * P_ * Hk.transpose();
  S.diagonal() += Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

  x_.noalias() += K * yk;
  P_ = (MatrixXf::Identity(15, 15) - K*Hk) * P_;
  return true;
}

