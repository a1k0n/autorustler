#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <iostream>

#include "drive/controller.h"
#include "drive/imgproc.h"

using Eigen::Matrix2f;
using Eigen::Matrix3f;
using Eigen::MatrixXf;
using Eigen::Vector2f;
using Eigen::Vector3f;
using Eigen::VectorXf;

static float MAX_THROTTLE = 0.3;
static float SPEED_LIMIT = 1;

static const float TRACTION_LIMIT = 3.0;  // maximum v*w product (m/s^2)
static const float kpy = 0.5;
static const float kvy = 1.5;

static const float LANE_OFFSET = 0;


// EKF state order, 13-dimensional:
// ye, psie, w, v, k, Cv, Tv, Cs, Ts, mu_s, mu_g, mu_ax, mu_ay
// 2.35488   -3.35807   -1.25895  -0.711344   0.234494   0.134446 -0.0395876    1.09513

DriveController::DriveController(): x_(15), P_(15, 15) {
  ResetState();
}

void DriveController::ResetState() {
  // set up initial state
  x_ << 
    // s_m, v, delta, y_e, psi_e, kappa
    0, 0, 0, 0, 0,
    // m1_ (log m/s^2) (overestimated for slow start)
    3.68, 
    // ml_2, ml_3 (both log 1/s)
    1.38, 0,
    // srv_a, srv_b, srv_r,
    1.0, 0, 3.0,
    // srvfb_ab
    -60, 117,
    // gyro offset
    0;

  P_.setZero();
  P_.diagonal() <<
    0.0001,     1.    ,     0.01  ,     4.    ,     1.    ,
    1.    ,     0.0625,     0.0625,     0.0625,     0.01  ,
    0.01  ,     0.01  ,  2500.    ,   100.    ,     1.;
}

static inline float clip(float x, float min, float max) {
  if (x < min) return min;
  if (x > max) return max;
  return x;
}

static inline float Heaviside(float x) {
  return x < 0 ? 0 : x;
}

static inline float Abs(float x) {
  return fabs(x);
}

static inline float Min(float x, float y) {
  return x < y ? x : y;
}

static inline float sign(float x) {
  return x < 0 ? -1 : 1;
}

void DriveController::PredictStep(
    float u_M, float u_delta, float Delta_t) {

  float s_m = x_[0], v = x_[1], delta = x_[2], y_e = x_[3], psi_e = x_[4],
  kappa = x_[5], ml_1 = x_[6], ml_2 = x_[7], ml_3 = x_[8], srv_a = x_[9],
  srv_b = x_[10], srv_r = x_[11], srvfb_a = x_[12], srvfb_b = x_[13], o_g = x_[14];

  x_[0] += Delta_t*v;
  x_[1] += Delta_t*(-v*exp(ml_2)*Abs(u_M) - v*exp(ml_3) + exp(ml_1)*Abs(u_M)*Heaviside(u_M));
  x_[2] += sign(-delta + srv_a*u_delta + srv_b)
    * Min(Delta_t*srv_r, Abs(-delta + srv_a*u_delta + srv_b));
  x_[3] += Delta_t*v*sin(psi_e);
  x_[4] += Delta_t*v*(delta + kappa*cos(psi_e)/(-kappa*y_e + 1));

  // ... dear reader, i am sorry about what you see here,
  // but take heart: this was autogenerated from sympy.

  float kye1 = -kappa * y_e + 1;
  float kye2 = kye1*kye1;
  MatrixXf Fk(15, 15);
  Fk <<
    1, Delta_t, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    0, Delta_t*(-exp(ml_2)*Abs(u_M) - exp(ml_3)) + 1, 0, 0, 0, 0, Delta_t*exp(ml_1)*Abs(u_M)*Heaviside(u_M), -Delta_t*v*exp(ml_2)*Abs(u_M), -Delta_t*v*exp(ml_3), 0, 0, 0, 0, 0, 0,

    0, 0, -Heaviside(Delta_t*srv_r - Abs(-delta + srv_a*u_delta + srv_b)) + 1, 0, 0, 0, 0, 0, 0, u_delta*Heaviside(Delta_t*srv_r - Abs(-delta + srv_a*u_delta + srv_b)), Heaviside(Delta_t*srv_r - Abs(-delta + srv_a*u_delta + srv_b)), Delta_t*Heaviside(-Delta_t*srv_r + Abs(-delta + srv_a*u_delta + srv_b))*sign(-delta + srv_a*u_delta + srv_b), 0, 0, 0,

    0, Delta_t*sin(psi_e), 0, 1, Delta_t*v*cos(psi_e), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    0, Delta_t*(delta + kappa*cos(psi_e)/(-kappa*y_e + 1)), Delta_t*v, Delta_t*kappa*kappa*v*cos(psi_e)/kye2, -Delta_t*kappa*v*sin(psi_e)/(-kappa*y_e + 1) + 1, Delta_t*v*(kappa*y_e*cos(psi_e)/kye2 + cos(psi_e)/(-kappa*y_e + 1)), 0, 0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1;

  // velocity fudge factor for determine covariance growth
  VectorXf Qk(15);
  Qk <<
      Delta_t * 0.2,  // 20 cm long pos error / s
      // v (m/s),
      Delta_t * 2,  // 2m/s^2 acceleration noise (?)
      // delta (dimensionless AKA 1),
      Delta_t * 2,  // 2 rad/s^2 (?)
      // y_e (m),
      Delta_t * 1,  // 1m/s position drift
      // psi_e (1),
      Delta_t * 1,  // 1 rad/s^2 (curvature errors)
      // kappa (1/m),
      // technically should be proportional to velocity here?
      Delta_t * 10,  // 1/m curvature can go from 0 to 2 at 5 m/s

      // rest are constants, shouldn't drift much
      // ml_1 (m/s^2), ml_2 (1/s), ml_3 (1/s),
      Delta_t * 1e-1, Delta_t * 1e-2, Delta_t * 1e-2,
      // srv_a (1/(m*control)), srv_b (1/m), srv_r (1/m*s)
      Delta_t * 1e-2, Delta_t * 1e-2, Delta_t * 1e-2,
      // srvfb_a (1/counts * m), srvfb_b (1/m),
      Delta_t * 1e-3, Delta_t * 1e-5,
      // o_g (1/s)
      Delta_t * 1e-3;

  P_ = Fk * P_ * Fk.transpose();
  P_.diagonal() += Qk;
}

void DriveController::UpdateCamera(const uint8_t *yuv) {
  Vector3f B;
  Matrix3f Rk;

  if (!TophatFilter(yuv, &B, &Rk)) {
    return;
  }
  // Rk(1, 1) += 0.01;  // slope is a bit iffy; add a bit of noise covariance

  // ok, we've obtained our linear fit B and our measurement covariance Rk
  // now do the sensor fusion step

  float s_m = x_[0], v = x_[1], delta = x_[2], y_e = x_[3], psi_e = x_[4],
  kappa = x_[5], ml_1 = x_[6], ml_2 = x_[7], ml_3 = x_[8], srv_a = x_[9],
  srv_b = x_[10], srv_r = x_[11], srvfb_a = x_[12], srvfb_b = x_[13], o_g = x_[14];

  float a = B[0], b = B[1], c = B[2];

  Vector3f z_k(-c, atan(b), 2*a*pow(b*b + 1, -1.5));
  Matrix3f Mk;
  Mk <<
    0, 0, -1,
    0, 1./(b*b + 1), 0,
    2*pow(b*b + 1, -1.5), -6*a*b*pow(b*b + 1, -2.5), 0;

  Vector3f y_k = z_k - Vector3f(y_e, psi_e, kappa);
  MatrixXf Hk(3, 15);
  Hk <<
    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0;

  Rk = Mk * Rk * Mk.transpose();
  Matrix3f S = Hk * P_ * Hk.transpose() + Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

#if 0
  std::cout << "mb_K\n" << K << "\n";
  std::cout << "y_k\n" << y_k.transpose()
    << " pred " << (B - y_k).transpose()
    << " meas " << B.transpose() << "\n";
#endif

  // finally, state update via kalman gain
  x_.noalias() += K * y_k;
  P_ = (MatrixXf::Identity(15, 15) - K*Hk) * P_;
}

void DriveController::UpdateIMU(
    const Vector3f &accel, const Vector3f &gyro,
    float u_acceleration) {
  float s_m = x_[0], v = x_[1], delta = x_[2], y_e = x_[3], psi_e = x_[4],
  kappa = x_[5], ml_1 = x_[6], ml_2 = x_[7], ml_3 = x_[8], srv_a = x_[9],
  srv_b = x_[10], srv_r = x_[11], srvfb_a = x_[12], srvfb_b = x_[13], o_g = x_[14];

  float zk = -v * delta + o_g;
  MatrixXf Hk(1, 15);
  Hk << 0, -delta, -v, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1;

  // const float g_conv = 9.8;
  float yk = gyro[2] - zk;
  // Vector3f(gyro[2], accel[0] * g_conv, accel[1] * g_conv) - zk;

  // accelerometer measurements are pretty noisy, almost not even worth it
  float Rk = 1e-2;

  Eigen::MatrixXf S = Hk * P_ * Hk.transpose();
  S(0, 0) += Rk;
  // S.diagonal() += Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

#if 0
  std::cout << "IMU_K\n" << K << "\n";
  std::cout << "y_k\n" << yk.transpose()
    << " pred " << zk.transpose()
    << " meas " << (yk + zk).transpose() << "\n";
#endif

  x_.noalias() += K * yk;
  P_ = (MatrixXf::Identity(15, 15) - K*Hk) * P_;
}

void DriveController::UpdateState(const uint8_t *yuv, size_t yuvlen,
      float throttle_in, float steering_in,
      const Vector3f &accel,
      const Vector3f &gyro, float dt) {

  if (isinf(x_[0]) || isnan(x_[0])) {
    fprintf(stderr, "WARNING: kalman filter diverged to inf/NaN! resetting!\n");
    ResetState();
  }

  PredictStep(throttle_in, steering_in, 1.0/30.0);
#if 0
  std::cout << "predict x" << x_.transpose() << std::endl;
  std::cout << "predict P" << P_.diagonal().transpose() << std::endl;
#endif
  if (yuvlen == 640*480 + 320*240*2) {
    UpdateCamera(yuv);
  } else {
    fprintf(stderr, "DriveController::UpdateState: invalid yuvlen %ld\n",
        yuvlen);
  }
#if 0
  std::cout << "camera x" << x_.transpose() << std::endl;
  std::cout << "camera P" << P_.diagonal().transpose() << std::endl;
#endif
  UpdateIMU(accel, gyro, throttle_in);

  if (x_[4] > M_PI/2) {
    x_[4] -= M_PI;
  } else if (x_[4] < -M_PI/2) {
    x_[4] += M_PI;
  }

  // TODO: read / update servo & encoders!

  // these don't line up anymore
  // x_[3] = fabsf(x_[3]);  // (velocity) dumb hack: keep us from going backwards when we're confused
  // x_[4] = fmax(fmin(x_[4], 0.3), -0.3);  // clip curvature so it doesn't go too extreme

  std::cout << "x " << x_.transpose() << std::endl;
  // std::cout << "P " << P_.diagonal().transpose() << std::endl;
}

static float MotorControl(float v_target, float k1, float k2, float k3, float v, float dt) {
  float v_thresh = (1 - k3 * dt) * v;
  // voltage (1 or 0)
  float V = v_target > v_thresh ? 1 : 0;
  // duty cycle
  float DC = clip((v_target + (k3*dt - 1)*v) / ((k1*V - k2*v)*dt), 0, 1);
  return V == 1 ? DC : -DC;
}

bool DriveController::GetControl(float *throttle_out, float *steering_out) {
  float s_m = x_[0], v = x_[1], delta = x_[2], y_e = x_[3], psi_e = x_[4],
  kappa = x_[5], ml_1 = x_[6], ml_2 = x_[7], ml_3 = x_[8], srv_a = x_[9],
  srv_b = x_[10], srv_r = x_[11], srvfb_a = x_[12], srvfb_b = x_[13], o_g = x_[14];

  float k1 = exp(ml_1), k2 = exp(ml_2), k3 = exp(ml_3);

  float vmax = fmin(SPEED_LIMIT, k1/(k2+k3));

  // TODO: race line following w/ particle filter localization
  float lane_offset = LANE_OFFSET;
  float psi_offset = 0;

  float cpsi = cos(psi_e - psi_offset),
        spsi = sin(psi_e - psi_offset);
  float dx = cpsi / (1.0 - kappa*y_e);

  // Alain Micaelli, Claude Samson. Trajectory tracking for unicycle-type and
  // two-steering-wheels mobile robots. [Research Report] RR-2097, INRIA. 1993.
  // <inria-00074575>

  // it's a little backwards though because our steering is reversed w.r.t. curvature
  float k_target = -dx * (-(y_e - lane_offset) * dx * kpy*cpsi - spsi*(-kappa*spsi - kvy*cpsi) + kappa);
  float v_target = fmin(vmax, sqrtf(TRACTION_LIMIT / fabs(k_target)));

  printf("steer_target %f delta %f v %f a %f/%f v %f y %f psi %f\n",
      k_target, delta, v, v*v*delta, TRACTION_LIMIT, v, y_e, psi_e);

  float dt = 1.0f/30;  // FIXME, should be an argument

  *steering_out = clip((k_target - srv_b) / srv_a, -1, 1);
  *throttle_out = clip(
      MotorControl(v_target, exp(ml_1), exp(ml_2), exp(ml_3), v, dt),
      -1, MAX_THROTTLE);

  printf("  throttle %f steer %f\n", *throttle_out, *steering_out);
  return true;
}

